{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Robert\\\\Documents\\\\Documents\\\\GitHub\\\\CSNW-Boggle-Interview\\\\app\\\\src\\\\components\\\\Game.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useState } from \"react\";\nimport '../style/Game.css';\nimport './global.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function Game() {\n  _s();\n  let n = global.board_size;\n  const [wordMatrix, setMatrix] = useState(Array.from({\n    length: n\n  }, () => Array.from({\n    length: n\n  }, () => null))); //should create an empty 4 by 4 array.\n  const [isFilled, setIsFilled] = useState(false); //boolean to check that the array is full\n\n  const [wordList, setWordList] = useState([]);\n  const [showResults, setShowResults] = useState(false); //bool for checking if to render results\n\n  //Result State\n  const [FoundWords, setFoundWords] = useState([]);\n  const [notFoundWords, setNotFoundWords] = useState([]);\n\n  //State change function handlers. \n  const handleMatrixFill = (row, column, event) => {\n    let result = event.target.value.replace(/[^-a-z]/ig, ''); //get rid of any non alphabet letters\n\n    if (result.length > 1) {\n      result = result.charAt(0); //make it so it can only be one character long\n    }\n\n    let copy = [...wordMatrix];\n    copy[row][column] = result;\n    setMatrix(copy);\n    let isFilled = true;\n    for (let i = 0; i < 4; i++) {\n      //check if all of the entries are filled. \n      for (let j = 0; j < 4; j++) {\n        if (copy[i][j] == null) {\n          //haven't filled this yet\n          isFilled = false;\n        } else if (copy[i][j].length < 1) {\n          //filled but got rid of letter\n          isFilled = false;\n        }\n      }\n    }\n    setIsFilled(isFilled);\n    console.log(copy);\n    console.log(isFilled);\n  };\n  const handleListAddition = word => {\n    word = word.replace(/[^-a-z]/ig, '');\n    let list_copy = wordList;\n    if (word != null) {\n      //check if we have a valid input\n      if (word.length > 0) {\n        list_copy.push(word); //add the word to the list\n        setWordList(list_copy);\n        console.log(list_copy);\n      }\n    }\n  };\n  const handleListRemoval = word => {\n    let list_copy = wordList;\n    let result = list_copy.filter(e => e !== word); // return the other words. \n    setWordList(result);\n    console.log(result);\n  };\n  const handleResults = (found_words, not_found_words) => {\n    console.log(found_words);\n    console.log(notFoundWords);\n    setFoundWords(found_words);\n    setNotFoundWords(not_found_words);\n    setShowResults(true);\n  };\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Boggle Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 117,\n      columnNumber: 8\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: \"Current Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 118,\n      columnNumber: 8\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game_interface\",\n      children: [/*#__PURE__*/_jsxDEV(WordBoardComponent, {\n        onFill: handleMatrixFill,\n        matrix: wordMatrix\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(WordListComponent, {\n        wordList: wordList,\n        onAdd: handleListAddition,\n        onRemove: handleListRemoval\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 129,\n        columnNumber: 10\n      }, this),\n      //only display play button if we can play\n      isFilled && wordList.length > 0 ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          PlayBoggle(wordMatrix, wordList, handleResults);\n        },\n        children: \"Play Boggle!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 138,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"h4\", {\n        children: \" Please add some words and fill in the word board to play Boggle\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 144,\n        columnNumber: 13\n      }, this), showResults ? /*#__PURE__*/_jsxDEV(ResultComponent, {\n        include: FoundWords,\n        excluded: notFoundWords\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 148,\n        columnNumber: 25\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 8\n    }, this)]\n  }, void 0, true);\n}\n_s(Game, \"IlZZKP4ZmHpHpeZFV6WeLBDSToE=\");\n_c = Game;\nfunction PlayBoggle(boggle_board, words, updateResults) {\n  global.found_words = [];\n  words.forEach(word => {\n    let entrance = word.charAt(0);\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        if (entrance == boggle_board[i][j]) {\n          //we found an entrance in the boggle board to start searching \n          global.paint_map = Array.from({\n            length: global.board_size\n          }, () => Array.from({\n            length: global.board_size\n          }, () => false)); //get a fresh unpainted map\n          recursivelyFindAllWords(word, word, i, j, boggle_board); //recursively search if it can be found\n          global.finish_traversal = false;\n        }\n      }\n    }\n  });\n\n  //handle game finished\n\n  let found_words = global.found_words;\n  let not_found_words = words;\n  found_words.forEach(word => {\n    not_found_words = not_found_words.filter(e => e !== word);\n  });\n  updateResults(found_words, not_found_words);\n}\n\n//Algorithm is O(m*n), where m is largest word in the list and n is the number of words. \n_c2 = PlayBoggle;\nfunction recursivelyFindAllWords(word, remaining, row, col, boggle_board) {\n  if (global.finish_traversal) {\n    //we have finished this current word traversal\n    return; //just return we're done\n  }\n\n  //base case\n  if (remaining.length == 0) {\n    //if we've traversed 2d array and have gotten to each word\n    global.finish_traversal = true;\n    global.found_words.push(word);\n  }\n\n  //Edge Case Checking\n  if (checkInBounds(row, col) == false) {\n    //we're out of bounds \n    return;\n  } else if (global.paint_map[row][col]) {\n    //we've been here already\n    return;\n  }\n  if (boggle_board[row][col] == remaining.charAt(0)) {\n    //we found the next spot!\n\n    global.paint_map[row][col] = true;\n\n    //try all of the other directions\n    let new_remaining = remaining.substring(1); //get remaining letters we need to find\n\n    recursivelyFindAllWords(word, new_remaining, row - 1, col, boggle_board); //square above\n\n    recursivelyFindAllWords(word, new_remaining, row + 1, col, boggle_board); //square below\n\n    recursivelyFindAllWords(word, new_remaining, row, col - 1, boggle_board); //square left\n\n    recursivelyFindAllWords(word, new_remaining, row, col + 1, boggle_board); //square right\n\n    recursivelyFindAllWords(word, new_remaining, row - 1, col - 1, boggle_board); //upper left corner\n\n    recursivelyFindAllWords(word, new_remaining, row + 1, col + 1, boggle_board); //lower right\n\n    recursivelyFindAllWords(word, new_remaining, row + 1, col - 1, boggle_board); //lower left\n\n    recursivelyFindAllWords(word, new_remaining, row - 1, col + 1, boggle_board); //upper right\n  }\n}\n\nfunction checkInBounds(row, col) {\n  if (row < 0) {\n    return false;\n  } else if (row >= global.board_size) {\n    return false;\n  } else if (col < 0) {\n    return false;\n  } else if (col >= global.board_size) {\n    return false;\n  }\n  return true;\n}\nconst ResultComponent = _ref => {\n  let {\n    included,\n    excluded\n  } = _ref;\n  const listItems = included === null || included === void 0 ? void 0 : included.map((word, key) =>\n  /*#__PURE__*/\n  //create list of potential words\n  _jsxDEV(ListComponent, {\n    word: word,\n    onRemove: null\n  }, key, false, {\n    fileName: _jsxFileName,\n    lineNumber: 317,\n    columnNumber: 12\n  }, this));\n  console.log(included);\n\n  /*\r\n      const included_words = included.map( (word, key)=>   \r\n      <ListComponent \r\n      word = {word}\r\n      onRemove= {null}\r\n      key = {key}\r\n     /> )\r\n  \r\n  \r\n  \r\n     const not_included_words = excluded.map( (word, key)=>   \r\n     <ListComponent \r\n      word = {word}\r\n      onRemove= {null}\r\n      key = {key}\r\n     /> )\r\n  */\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Found Words\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 346,\n        columnNumber: 13\n      }, this), listItems]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 345,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Missed Words\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 354,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 344,\n    columnNumber: 5\n  }, this);\n};\n\n//\n_c3 = ResultComponent;\nconst WordBoardComponent = _ref2 => {\n  let {\n    onFill,\n    matrix\n  } = _ref2;\n  //this is going to display a board and have functions that will change the state of 2d array in Game component \n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"Board\",\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Word Board\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 382,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"table\", {\n      children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n        children: matrix.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"tr\", {\n          children: row.map((column, columnIndex) => /*#__PURE__*/_jsxDEV(\"td\", {\n            children: /*#__PURE__*/_jsxDEV(\"input\", {\n              type: \"text\",\n              onChange: e => onFill(rowIndex, columnIndex, e),\n              value: matrix[rowIndex][columnIndex] == null ? '' : matrix[rowIndex][columnIndex]\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 391,\n              columnNumber: 25\n            }, this)\n          }, columnIndex, false, {\n            fileName: _jsxFileName,\n            lineNumber: 390,\n            columnNumber: 25\n          }, this))\n        }, rowIndex, false, {\n          fileName: _jsxFileName,\n          lineNumber: 388,\n          columnNumber: 17\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 386,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 385,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"caption\",\n      children: /*#__PURE__*/_jsxDEV(\"h5\", {\n        children: \"Fill Me In!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 404,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 403,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 381,\n    columnNumber: 5\n  }, this);\n};\n_c4 = WordBoardComponent;\nconst ListComponent = _ref3 => {\n  let {\n    word,\n    onRemove,\n    my_key\n  } = _ref3;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"list_item\",\n    children: [word, onRemove != null ? /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        onRemove(word);\n      },\n      children: \"Remove\"\n    }, my_key, false, {\n      fileName: _jsxFileName,\n      lineNumber: 420,\n      columnNumber: 32\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false), \";\"]\n  }, my_key, true, {\n    fileName: _jsxFileName,\n    lineNumber: 418,\n    columnNumber: 9\n  }, this);\n};\n_c5 = ListComponent;\nconst WordListComponent = _ref4 => {\n  _s2();\n  let {\n    wordList,\n    onAdd,\n    onRemove\n  } = _ref4;\n  const [chosenWord, setChosenWord] = useState('');\n  const listItems = wordList.map((word, key) =>\n  /*#__PURE__*/\n  //create list of potential words\n  _jsxDEV(ListComponent, {\n    word: word,\n    onRemove: onRemove\n  }, key, false, {\n    fileName: _jsxFileName,\n    lineNumber: 434,\n    columnNumber: 12\n  }, this));\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [wordList.length == 0 ? /*#__PURE__*/_jsxDEV(\"h5\", {\n      children: \" You haven't added any words!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 445,\n      columnNumber: 36\n    }, this) : /*#__PURE__*/_jsxDEV(\"h5\", {\n      children: \"Your Chosen Words\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 445,\n      columnNumber: 77\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"item_list\",\n      children: /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [\"  \", listItems, \" \"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 450,\n        columnNumber: 8\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 447,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"text\",\n      onChange: e => {\n        setChosenWord(e.target.value);\n      },\n      value: chosenWord\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 454,\n      columnNumber: 8\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => {\n        //submit the chosen word to the list and reset\n        onAdd(chosenWord);\n        setChosenWord('');\n      },\n      children: \"Add Word\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 459,\n      columnNumber: 9\n    }, this), \";\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 443,\n    columnNumber: 5\n  }, this);\n};\n_s2(WordListComponent, \"50ABnTByugnF4nma4edwToen2B0=\");\n_c6 = WordListComponent;\nconst results = () => {};\nvar _c, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"Game\");\n$RefreshReg$(_c2, \"PlayBoggle\");\n$RefreshReg$(_c3, \"ResultComponent\");\n$RefreshReg$(_c4, \"WordBoardComponent\");\n$RefreshReg$(_c5, \"ListComponent\");\n$RefreshReg$(_c6, \"WordListComponent\");","map":{"version":3,"names":["useState","jsxDEV","_jsxDEV","Fragment","_Fragment","Game","_s","n","global","board_size","wordMatrix","setMatrix","Array","from","length","isFilled","setIsFilled","wordList","setWordList","showResults","setShowResults","FoundWords","setFoundWords","notFoundWords","setNotFoundWords","handleMatrixFill","row","column","event","result","target","value","replace","charAt","copy","i","j","console","log","handleListAddition","word","list_copy","push","handleListRemoval","filter","e","handleResults","found_words","not_found_words","children","fileName","_jsxFileName","lineNumber","columnNumber","className","WordBoardComponent","onFill","matrix","WordListComponent","onAdd","onRemove","onClick","PlayBoggle","ResultComponent","include","excluded","_c","boggle_board","words","updateResults","forEach","entrance","paint_map","recursivelyFindAllWords","finish_traversal","_c2","remaining","col","checkInBounds","new_remaining","substring","_ref","included","listItems","map","key","ListComponent","_c3","_ref2","rowIndex","columnIndex","type","onChange","_c4","_ref3","my_key","_c5","_ref4","_s2","chosenWord","setChosenWord","_c6","results","$RefreshReg$"],"sources":["C:/Users/Robert/Documents/Documents/GitHub/CSNW-Boggle-Interview/app/src/components/Game.js"],"sourcesContent":["\r\nimport { useState } from \"react\";\r\n\r\nimport '../style/Game.css';\r\nimport './global.js'\r\n\r\nexport default function Game()\r\n{\r\n\r\n  \r\n    let n = global.board_size\r\n    const [wordMatrix, setMatrix] = useState(Array.from({length: n},()=> Array.from({length: n}, () => null)));    //should create an empty 4 by 4 array.\r\n    const [isFilled, setIsFilled] = useState(false);                                                                 //boolean to check that the array is full\r\n\r\n    const [wordList, setWordList] = useState([]); \r\n    const [showResults, setShowResults] = useState(false); //bool for checking if to render results\r\n\r\n    //Result State\r\n    const [FoundWords, setFoundWords] = useState([]);\r\n    const [notFoundWords, setNotFoundWords] = useState([]); \r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n    //State change function handlers. \r\n    const handleMatrixFill = (row, column, event) => {\r\n\r\n        let result = event.target.value.replace(/[^-a-z]/ig,''); //get rid of any non alphabet letters\r\n\r\n        if(result.length>1)\r\n        {\r\n            result = result.charAt(0) //make it so it can only be one character long\r\n        }\r\n\r\n\r\n        let copy = [...wordMatrix];\r\n        copy[row][column] = result\r\n        setMatrix(copy);\r\n\r\n        let isFilled = true\r\n\r\n\r\n        for(let i =0; i < 4; i++)\r\n        { //check if all of the entries are filled. \r\n            for(let j =0; j < 4; j++)\r\n            {\r\n                if(copy[i][j] == null)\r\n                { //haven't filled this yet\r\n                    isFilled =false\r\n                }\r\n                else if(copy[i][j].length <1)\r\n                { //filled but got rid of letter\r\n                    isFilled = false\r\n                }\r\n\r\n                }\r\n        }\r\n\r\n        setIsFilled(isFilled)\r\n\r\n        console.log(copy);\r\n        console.log(isFilled); \r\n    };\r\n\r\n\r\n    const handleListAddition = (word) => {\r\n    \r\n    \r\n        word = word.replace(/[^-a-z]/ig,'');\r\n        let list_copy = wordList; \r\n\r\n        if(word != null)\r\n        { //check if we have a valid input\r\n            if(word.length > 0)\r\n            {\r\n                list_copy.push(word) //add the word to the list\r\n                setWordList(list_copy)\r\n                console.log(list_copy)\r\n            }\r\n\r\n        }\r\n\r\n     \r\n     \r\n\r\n\r\n    }; \r\n\r\n    const handleListRemoval = (word) => {\r\n\r\n\r\n        let list_copy = wordList; \r\n        let result = list_copy.filter(e => e !== word); // return the other words. \r\n        setWordList(result)\r\n        console.log(result)\r\n    }; \r\n\r\n    const handleResults = (found_words, not_found_words) =>{\r\n\r\n        console.log(found_words)\r\n        console.log(notFoundWords)\r\n        setFoundWords(found_words)\r\n        setNotFoundWords(not_found_words); \r\n        setShowResults(true); \r\n        \r\n    }\r\n\r\n\r\n\r\n\r\n    return(\r\n        <>\r\n\r\n       <h3>Boggle Game</h3>\r\n       <h4>\r\n        Current Game\r\n       </h4>\r\n\r\n       <div className = \"game_interface\">\r\n\r\n        <WordBoardComponent\r\n            onFill ={handleMatrixFill }\r\n            matrix ={wordMatrix}\r\n         />\r\n\r\n         <WordListComponent\r\n            wordList ={wordList}\r\n            onAdd ={handleListAddition}\r\n            onRemove ={handleListRemoval}\r\n         />\r\n\r\n\r\n         { //only display play button if we can play\r\n            isFilled && wordList.length >0 ? \r\n            <button onClick = { ()=> {\r\n                \r\n                \r\n                PlayBoggle(wordMatrix, wordList, handleResults)\r\n        \r\n        }}>Play Boggle!</button > :\r\n            <h4> Please add some words and fill in the word board to play Boggle</h4>\r\n         }\r\n\r\n\r\n         {showResults ? <ResultComponent \r\n            include = {FoundWords}\r\n            excluded= {notFoundWords}\r\n         />: <></>}\r\n\r\n\r\n\r\n        </div>\r\n    \r\n        </>\r\n\r\n    ); \r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nfunction PlayBoggle(boggle_board, words, updateResults)\r\n{\r\n    global.found_words = [];\r\n    words.forEach(word => {\r\n\r\n         let entrance = word.charAt(0); \r\n\r\n         for(let i = 0; i < 4; i++)\r\n         {\r\n            for(let j = 0; j < 4; j++)\r\n            {\r\n                if(entrance == boggle_board[i][j])\r\n                { //we found an entrance in the boggle board to start searching \r\n                    global.paint_map = Array.from({length: global.board_size},()=> Array.from({length: global.board_size}, () => false)) //get a fresh unpainted map\r\n                    recursivelyFindAllWords(word, word, i, j, boggle_board) //recursively search if it can be found\r\n                    global.finish_traversal = false; \r\n                }\r\n\r\n            }\r\n\r\n         }\r\n        \r\n        \r\n\r\n    });\r\n\r\n    //handle game finished\r\n   \r\n\r\n    let found_words = global.found_words;\r\n    let not_found_words = words\r\n\r\n     found_words.forEach(\r\n\r\n        (word) =>\r\n        {\r\n            not_found_words = not_found_words.filter((e) => e!== word);\r\n\r\n        }\r\n\r\n\r\n     )\r\n\r\n     updateResults(found_words, not_found_words); \r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n//Algorithm is O(m*n), where m is largest word in the list and n is the number of words. \r\nfunction recursivelyFindAllWords(word, remaining, row , col, boggle_board)\r\n{\r\n\r\n\r\n    if(global.finish_traversal)\r\n    { //we have finished this current word traversal\r\n        return; //just return we're done\r\n        \r\n    }\r\n    \r\n\r\n    //base case\r\n    if(remaining.length == 0)\r\n    { //if we've traversed 2d array and have gotten to each word\r\n        global.finish_traversal = true; \r\n        global.found_words.push(word); \r\n    }\r\n\r\n  \r\n\r\n   //Edge Case Checking\r\n    if(checkInBounds(row,col) == false  )\r\n    { //we're out of bounds \r\n        return; \r\n    }\r\n    else if(global.paint_map[row][col])\r\n    { //we've been here already\r\n        return; \r\n    }\r\n\r\n\r\n    \r\n    if(boggle_board[row][col] == remaining.charAt(0))\r\n    { //we found the next spot!\r\n\r\n        global.paint_map[row][col] = true; \r\n\r\n        //try all of the other directions\r\n        let new_remaining = remaining.substring(1); //get remaining letters we need to find\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row-1, col, boggle_board) //square above\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row+1, col, boggle_board) //square below\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row, col-1, boggle_board) //square left\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row, col+1, boggle_board) //square right\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row-1, col-1, boggle_board) //upper left corner\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row+1, col+1, boggle_board) //lower right\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row+1, col-1, boggle_board) //lower left\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row-1, col+1, boggle_board) //upper right\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nfunction checkInBounds(row, col)\r\n{\r\n\r\n    if(row < 0)\r\n    {\r\n        return false \r\n    }\r\n    else if(row >= global.board_size)\r\n    {\r\n        return false\r\n\r\n    } else if (col < 0)\r\n    {\r\n        return false\r\n\r\n    }\r\n    else if ( col >= global.board_size)\r\n    {\r\n        return false\r\n\r\n    }\r\n\r\n\r\n    return true\r\n}\r\n\r\n\r\n\r\n\r\nconst ResultComponent = ({included, excluded})=>\r\n{\r\n\r\n    \r\n    const listItems = included?.map( (word, key) =>//create list of potential words\r\n           <ListComponent \r\n            word = {word}\r\n            onRemove= {null}\r\n            key = {key}\r\n           />\r\n); \r\nconsole.log(included)\r\n\r\n/*\r\n    const included_words = included.map( (word, key)=>   \r\n    <ListComponent \r\n    word = {word}\r\n    onRemove= {null}\r\n    key = {key}\r\n   /> )\r\n\r\n\r\n\r\n   const not_included_words = excluded.map( (word, key)=>   \r\n   <ListComponent \r\n    word = {word}\r\n    onRemove= {null}\r\n    key = {key}\r\n   /> )\r\n*/\r\n   return(\r\n\r\n    <div>\r\n        <div>\r\n            <h3>\r\n                Found Words\r\n            </h3>\r\n            {listItems}\r\n\r\n        </div>\r\n\r\n        <div>\r\n            <h3>\r\n                Missed Words\r\n            </h3>\r\n            {}\r\n\r\n        </div>\r\n       \r\n\r\n\r\n    </div>\r\n\r\n   ); \r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//\r\n\r\n\r\nconst WordBoardComponent = ({onFill,  matrix})=>\r\n{ //this is going to display a board and have functions that will change the state of 2d array in Game component \r\n\r\n    return(\r\n    <div className=\"Board\">\r\n        <h3>\r\n            Word Board\r\n        </h3>\r\n        <table>\r\n            <tbody>\r\n            {matrix.map((row, rowIndex) => (\r\n                <tr key={rowIndex}>\r\n                    {row.map((column, columnIndex) => (\r\n                        <td key={columnIndex}>\r\n                        <input\r\n                        type=\"text\"\r\n                        onChange={(e) => onFill(rowIndex, columnIndex, e)}\r\n                        value={matrix[rowIndex][columnIndex] == null ? '' : matrix[rowIndex][columnIndex]  }\r\n                        />\r\n                        </td>\r\n                    ))}\r\n                </tr>\r\n                ))}\r\n            </tbody>\r\n        </table>\r\n\r\n        <div className=\"caption\">\r\n        <h5>Fill Me In!</h5>\r\n        </div>\r\n\r\n    </div>\r\n    ); \r\n\r\n\r\n}\r\n\r\n\r\nconst ListComponent = ({word, onRemove, my_key}) => {\r\n\r\n    return(\r\n\r\n        <div className = \"list_item\" key = {my_key}>\r\n            {word}\r\n            { onRemove!=null ? <button key = {my_key} onClick={ ()=> {onRemove(word)}}>Remove</button> : <></>};\r\n\r\n        </div>\r\n\r\n    )\r\n}\r\n\r\nconst WordListComponent = ({wordList, onAdd, onRemove}) => {\r\n\r\n    \r\n    const [chosenWord, setChosenWord] = useState(''); \r\n\r\n   \r\n    const listItems = wordList.map( (word, key) =>//create list of potential words\r\n           <ListComponent \r\n            word = {word}\r\n            onRemove= {onRemove}\r\n            key = {key}\r\n           />\r\n); \r\n\r\n\r\n   return(\r\n    <div>\r\n\r\n            {wordList.length ==0 ? <h5> You haven't added any words!</h5> : <h5>Your Chosen Words</h5>}\r\n  \r\n        <div className=\"item_list\"> \r\n\r\n        \r\n       <ul>  {listItems} </ul>\r\n\r\n       </div>\r\n\r\n       <input\r\n        type=\"text\"\r\n        onChange={(e)=>{ setChosenWord(e.target.value)}}\r\n        value = {chosenWord}\r\n        />\r\n        <button onClick={ ()=>{\r\n            //submit the chosen word to the list and reset\r\n            onAdd(chosenWord); \r\n            setChosenWord(''); \r\n        }\r\n            \r\n            }>Add Word</button>;\r\n\r\n\r\n    </div>\r\n   ); \r\n\r\n\r\n\r\n}\r\n\r\nconst results = () =>{\r\n\r\n}\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}