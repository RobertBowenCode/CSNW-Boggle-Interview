{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Robert\\\\Documents\\\\Documents\\\\GitHub\\\\CSNW-Boggle-Interview\\\\app\\\\client\\\\src\\\\components\\\\Game.js\",\n  _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport '../style/Game.css';\nimport './global.js';\nimport WordListComponent from './WordListComponent';\nimport WordBoardComponent from './WordBoardComponent';\nimport ResultComponent from './ResultComponent';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function Game(onSaveHistory) {\n  _s();\n  let n = global.board_size;\n  const [wordMatrix, setMatrix] = useState(Array.from({\n    length: n\n  }, () => Array.from({\n    length: n\n  }, () => null))); //should create an empty 4 by 4 array.\n  const [isFilled, setIsFilled] = useState(false); //boolean to check that the array is full\n\n  const [wordList, setWordList] = useState([]); //list of words\n  const [showResults, setShowResults] = useState(false); //bool for checking if to render results\n  const [canPlay, setCanPlay] = useState(false); //bool for checking if can play\n\n  //Result State\n  const [FoundWords, setFoundWords] = useState([]); //list of founds words in the boggle game\n\n  //State change function handlers. \n  const handleMatrixFill = (row, column, event) => {\n    let result = event.target.value.replace(/[^-a-z]/ig, ''); //get rid of any non alphabet letters\n    result = result.toLowerCase();\n    if (result.length > 1) {\n      result = result.charAt(0); //make it so it can only be one character long\n    }\n\n    let copy = [...wordMatrix];\n    copy[row][column] = result;\n    setMatrix(copy);\n    let isFilled = true;\n    for (let i = 0; i < 4; i++) {\n      //check if all of the entries are filled. \n      for (let j = 0; j < 4; j++) {\n        if (copy[i][j] == null) {\n          //haven't filled this yet\n          isFilled = false;\n        } else if (copy[i][j].length < 1) {\n          //filled but got rid of letter\n          isFilled = false;\n        }\n      }\n    }\n    setIsFilled(isFilled);\n  };\n  const handleListAddition = word => {\n    word = word.replace(/[^-a-z]/ig, ''); //only Letters!\n    word = word.toLowerCase();\n    let list_copy = wordList;\n    list_copy = list_copy.filter(e => e !== word); // avoid duplicates\n    if (word != null) {\n      //check if we have a valid input\n      if (word.length > 0) {\n        list_copy.push(word); //add the word to the list\n      }\n    }\n\n    setWordList(list_copy);\n  };\n  const handleListRemoval = word => {\n    let list_copy = wordList;\n    let result = list_copy.filter(e => e !== word); // return the other words. \n    setWordList(result);\n    console.log(result);\n  };\n  const handleResults = found_words => {\n    console.log(\"this is the found words\");\n    console.log(\"found words\");\n    setFoundWords(found_words);\n  };\n  useEffect(() => {\n    if (wordList.length > 0) {\n      setShowResults(true);\n    }\n  }, [FoundWords]);\n  useEffect(() => {\n    if (wordList.length > 0 && isFilled) {\n      //if the word list is larger than 0 and the board is filled\n\n      setCanPlay(true);\n    } else {\n      setCanPlay(false);\n    }\n  }, [wordList, isFilled]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"Boggle Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 146,\n      columnNumber: 8\n    }, this), /*#__PURE__*/_jsxDEV(\"h4\", {\n      children: \"Current Game\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 147,\n      columnNumber: 8\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game_interface\",\n      children: [/*#__PURE__*/_jsxDEV(WordBoardComponent, {\n        onFill: handleMatrixFill,\n        matrix: wordMatrix\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 153,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(WordListComponent, {\n        wordList: wordList,\n        onAdd: handleListAddition,\n        onRemove: handleListRemoval\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 10\n      }, this),\n      //only display play button if we can play\n      canPlay ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          PlayBoggle(wordMatrix, wordList, handleResults);\n        },\n        children: \"Play Boggle!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 167,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"h4\", {\n        children: \" Please add some words and fill in the word board to play Boggle\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 173,\n        columnNumber: 13\n      }, this), showResults ? /*#__PURE__*/_jsxDEV(ResultComponent, {\n        found_words: FoundWords,\n        all_words: wordList\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 177,\n        columnNumber: 25\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false), showResults ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          resetGame(setShowResults, setCanPlay, setWordList, setFoundWords, setIsFilled, setMatrix);\n        },\n        children: \"Play Another Game!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 23\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false), showResults ? /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          onSaveHistory(wordMatrix, FoundWords, wordList);\n        },\n        children: \"Save This Game!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 23\n      }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 151,\n      columnNumber: 8\n    }, this)]\n  }, void 0, true);\n}\n_s(Game, \"S4nCniybp6JPx2ompV2UsMBZk0U=\");\n_c = Game;\nfunction resetGame(resetShowResults, resetCanPlay, resetWordList, resetFoundWords, resetIsFilled, resetMatrix) {\n  resetShowResults(false);\n  resetCanPlay(false);\n  resetWordList([]);\n  resetFoundWords([]);\n  resetIsFilled(false);\n  resetMatrix(Array.from({\n    length: global.board_size\n  }, () => Array.from({\n    length: global.board_size\n  }, () => null)));\n}\nfunction saveGame() {\n  //will call hook passed by upper layer\n}\nfunction PlayBoggle(boggle_board, words, updateResults) {\n  global.found_words = [];\n  words.forEach(word => {\n    let entrance = word.charAt(0);\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        if (entrance === boggle_board[i][j]) {\n          //we found an entrance in the boggle board to start searching \n          global.paint_map = Array.from({\n            length: global.board_size\n          }, () => Array.from({\n            length: global.board_size\n          }, () => false)); //get a fresh unpainted map\n          recursivelyFindAllWords(word, word, i, j, boggle_board); //recursively search if it can be found\n\n          if (global.finish_traversal == true) {\n            //avoid repeatedly finding the same word at different entrances. \n            j = 4;\n            i = 4;\n          }\n          global.finish_traversal = false;\n        }\n      }\n    }\n  });\n\n  //handle game finished\n\n  let found_words = global.found_words;\n  updateResults(found_words);\n}\n\n//Algorithm is O(m*n), where m is largest word in the list and n is the number of words. \n_c2 = PlayBoggle;\nfunction recursivelyFindAllWords(word, remaining, row, col, boggle_board) {\n  if (global.finish_traversal) {\n    //we have finished this current word traversal\n    return; //just return we're done\n  }\n\n  //base case\n  if (remaining.length === 0) {\n    //if we've traversed 2d array and have gotten to each letter\n    global.finish_traversal = true;\n    global.found_words.push(word);\n  }\n\n  //Edge Case Checking\n  if (checkInBounds(row, col) == false) {\n    //we're out of bounds \n    return;\n  } else if (global.paint_map[row][col]) {\n    //we've been here already\n    return;\n  }\n  if (boggle_board[row][col] === remaining.charAt(0)) {\n    //we found the next spot!\n\n    global.paint_map[row][col] = true;\n\n    //try all of the other directions\n    let new_remaining = remaining.substring(1); //get remaining letters we need to find\n\n    recursivelyFindAllWords(word, new_remaining, row - 1, col, boggle_board); //square above\n\n    recursivelyFindAllWords(word, new_remaining, row + 1, col, boggle_board); //square below\n\n    recursivelyFindAllWords(word, new_remaining, row, col - 1, boggle_board); //square left\n\n    recursivelyFindAllWords(word, new_remaining, row, col + 1, boggle_board); //square right\n\n    recursivelyFindAllWords(word, new_remaining, row - 1, col - 1, boggle_board); //upper left \n\n    recursivelyFindAllWords(word, new_remaining, row + 1, col + 1, boggle_board); //lower right\n\n    recursivelyFindAllWords(word, new_remaining, row + 1, col - 1, boggle_board); //lower left\n\n    recursivelyFindAllWords(word, new_remaining, row - 1, col + 1, boggle_board); //upper right\n  }\n}\n\nfunction checkInBounds(row, col) {\n  if (row < 0) {\n    return false;\n  } else if (row >= global.board_size) {\n    return false;\n  } else if (col < 0) {\n    return false;\n  } else if (col >= global.board_size) {\n    return false;\n  }\n  return true;\n}\nvar _c, _c2;\n$RefreshReg$(_c, \"Game\");\n$RefreshReg$(_c2, \"PlayBoggle\");","map":{"version":3,"names":["useState","useEffect","WordListComponent","WordBoardComponent","ResultComponent","jsxDEV","_jsxDEV","Fragment","_Fragment","Game","onSaveHistory","_s","n","global","board_size","wordMatrix","setMatrix","Array","from","length","isFilled","setIsFilled","wordList","setWordList","showResults","setShowResults","canPlay","setCanPlay","FoundWords","setFoundWords","handleMatrixFill","row","column","event","result","target","value","replace","toLowerCase","charAt","copy","i","j","handleListAddition","word","list_copy","filter","e","push","handleListRemoval","console","log","handleResults","found_words","children","fileName","_jsxFileName","lineNumber","columnNumber","className","onFill","matrix","onAdd","onRemove","onClick","PlayBoggle","all_words","resetGame","_c","resetShowResults","resetCanPlay","resetWordList","resetFoundWords","resetIsFilled","resetMatrix","saveGame","boggle_board","words","updateResults","forEach","entrance","paint_map","recursivelyFindAllWords","finish_traversal","_c2","remaining","col","checkInBounds","new_remaining","substring","$RefreshReg$"],"sources":["C:/Users/Robert/Documents/Documents/GitHub/CSNW-Boggle-Interview/app/client/src/components/Game.js"],"sourcesContent":["\r\nimport { useState, useEffect } from 'react';\r\n\r\nimport '../style/Game.css';\r\nimport './global.js';\r\nimport WordListComponent from './WordListComponent';\r\nimport WordBoardComponent from './WordBoardComponent'; \r\nimport ResultComponent from './ResultComponent'; \r\n\r\n\r\nexport default function Game(onSaveHistory)\r\n{\r\n\r\n  \r\n    let n = global.board_size\r\n    const [wordMatrix, setMatrix] = useState(Array.from({length: n},()=> Array.from({length: n}, () => null)));    //should create an empty 4 by 4 array.\r\n    const [isFilled, setIsFilled] = useState(false);                                                               //boolean to check that the array is full\r\n\r\n    const [wordList, setWordList] = useState([]); //list of words\r\n    const [showResults, setShowResults] = useState(false); //bool for checking if to render results\r\n    const [canPlay, setCanPlay] = useState(false); //bool for checking if can play\r\n\r\n    //Result State\r\n    const [FoundWords, setFoundWords] = useState([]); //list of founds words in the boggle game\r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n    //State change function handlers. \r\n    const handleMatrixFill = (row, column, event) => {\r\n\r\n        let result = event.target.value.replace(/[^-a-z]/ig,''); //get rid of any non alphabet letters\r\n        result = result.toLowerCase(); \r\n\r\n        if(result.length>1)\r\n        {\r\n            result = result.charAt(0) //make it so it can only be one character long\r\n        }\r\n\r\n\r\n        let copy = [...wordMatrix];\r\n        copy[row][column] = result\r\n        setMatrix(copy);\r\n\r\n        let isFilled = true\r\n\r\n\r\n        for(let i =0; i < 4; i++)\r\n        { //check if all of the entries are filled. \r\n            for(let j =0; j < 4; j++)\r\n            {\r\n                if(copy[i][j] == null)\r\n                { //haven't filled this yet\r\n                    isFilled =false\r\n                }\r\n                else if(copy[i][j].length <1)\r\n                { //filled but got rid of letter\r\n                    isFilled = false\r\n                }\r\n\r\n                }\r\n        }\r\n\r\n        setIsFilled(isFilled)\r\n\r\n    };\r\n\r\n\r\n    const handleListAddition = (word) => {\r\n    \r\n    \r\n        word = word.replace(/[^-a-z]/ig,''); //only Letters!\r\n        word = word.toLowerCase(); \r\n\r\n        let list_copy = wordList; \r\n        list_copy = list_copy.filter(e => e !== word); // avoid duplicates\r\n        if(word != null)\r\n        { //check if we have a valid input\r\n            if(word.length > 0)\r\n            {\r\n                list_copy.push(word) //add the word to the list\r\n                \r\n\r\n            }\r\n\r\n        }\r\n\r\n        setWordList(list_copy)\r\n     \r\n\r\n\r\n    }; \r\n\r\n    const handleListRemoval = (word) => {\r\n\r\n\r\n        let list_copy = wordList; \r\n        let result = list_copy.filter(e => e !== word); // return the other words. \r\n        setWordList(result)\r\n        console.log(result)\r\n    }; \r\n\r\n\r\n    const handleResults = (found_words) =>{\r\n\r\n        console.log(\"this is the found words\")\r\n        console.log(\"found words\")\r\n\r\n        setFoundWords(found_words)\r\n\r\n        \r\n    }\r\n\r\n\r\n    \r\n    useEffect(() => {\r\n\r\n        if(wordList.length > 0)\r\n        {\r\n\r\n            setShowResults(true);\r\n        }  \r\n    }, [FoundWords])\r\n\r\n\r\n    useEffect(() => {\r\n\r\n        if(wordList.length > 0 && isFilled)\r\n        { //if the word list is larger than 0 and the board is filled\r\n\r\n            setCanPlay(true);\r\n        }  \r\n        else{\r\n            setCanPlay(false); \r\n        }\r\n    }, [wordList, isFilled])\r\n\r\n\r\n\r\n    return(\r\n        <>\r\n\r\n       <h3>Boggle Game</h3>\r\n       <h4>\r\n        Current Game\r\n       </h4>\r\n\r\n       <div className = \"game_interface\">\r\n\r\n        <WordBoardComponent\r\n            onFill ={handleMatrixFill }\r\n            matrix ={wordMatrix}\r\n         />\r\n\r\n         <WordListComponent\r\n            wordList ={wordList}\r\n            onAdd ={handleListAddition}\r\n            onRemove ={handleListRemoval}\r\n         />\r\n\r\n\r\n         { //only display play button if we can play\r\n            canPlay ? \r\n            <button onClick = { ()=> {\r\n                \r\n                \r\n                PlayBoggle(wordMatrix, wordList, handleResults)\r\n        \r\n        }}>Play Boggle!</button > :\r\n            <h4> Please add some words and fill in the word board to play Boggle</h4>\r\n         }\r\n\r\n\r\n         {showResults ? <ResultComponent \r\n            found_words = {FoundWords}\r\n            all_words= {wordList}\r\n         />: <></>}\r\n\r\n\r\n       {showResults ? <button onClick = { ()=> {   \r\n\r\n        resetGame(setShowResults, setCanPlay, setWordList, setFoundWords, setIsFilled, setMatrix); \r\n        \r\n        }}>Play Another Game!</button > : <></>}\r\n\r\n        \r\n       {showResults ? <button onClick = { ()=> {   \r\n\r\n            onSaveHistory(wordMatrix, FoundWords, wordList)\r\n\r\n}}>Save This Game!</button > : <></>}\r\n\r\n\r\n        </div>\r\n    \r\n        </>\r\n\r\n    ); \r\n\r\n\r\n\r\n}\r\n\r\nfunction resetGame(resetShowResults, resetCanPlay, resetWordList, resetFoundWords, resetIsFilled, resetMatrix)\r\n{\r\n    resetShowResults(false); \r\n    resetCanPlay(false)\r\n    resetWordList([])\r\n    resetFoundWords([])\r\n    resetIsFilled(false)\r\n    resetMatrix(Array.from({length: global.board_size},()=> Array.from({length: global.board_size}, () => null)))\r\n\r\n}\r\n\r\n\r\nfunction saveGame()\r\n{\r\n //will call hook passed by upper layer\r\n\r\n\r\n}\r\n\r\nfunction PlayBoggle(boggle_board, words, updateResults)\r\n{\r\n\r\n    global.found_words = [];\r\n\r\n    words.forEach(word => {\r\n\r\n         let entrance = word.charAt(0); \r\n\r\n         for(let i = 0; i < 4; i++)\r\n         {\r\n            for(let j = 0; j < 4; j++)\r\n            {\r\n                if(entrance === boggle_board[i][j])\r\n                { //we found an entrance in the boggle board to start searching \r\n                    global.paint_map = Array.from({length: global.board_size},()=> Array.from({length: global.board_size}, () => false)) //get a fresh unpainted map\r\n                    recursivelyFindAllWords(word, word, i, j, boggle_board) //recursively search if it can be found\r\n\r\n                    if(global.finish_traversal == true)\r\n                    {//avoid repeatedly finding the same word at different entrances. \r\n                        j = 4; \r\n                        i = 4; \r\n                    }\r\n\r\n                    global.finish_traversal = false; \r\n                }\r\n\r\n            }\r\n\r\n         }\r\n        \r\n        \r\n\r\n    });\r\n\r\n    //handle game finished\r\n   \r\n\r\n    let found_words = global.found_words;\r\n\r\n\r\n     updateResults(found_words); \r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n//Algorithm is O(m*n), where m is largest word in the list and n is the number of words. \r\nfunction recursivelyFindAllWords(word, remaining, row , col, boggle_board)\r\n{\r\n\r\n\r\n    if(global.finish_traversal)\r\n    { //we have finished this current word traversal\r\n        return; //just return we're done\r\n        \r\n    }\r\n    \r\n\r\n    //base case\r\n    if(remaining.length === 0)\r\n    { //if we've traversed 2d array and have gotten to each letter\r\n        global.finish_traversal = true; \r\n        global.found_words.push(word); \r\n    }\r\n\r\n  \r\n\r\n   //Edge Case Checking\r\n    if(checkInBounds(row,col) == false  )\r\n    { //we're out of bounds \r\n        return; \r\n    }\r\n    else if(global.paint_map[row][col])\r\n    { //we've been here already\r\n        return; \r\n    }\r\n\r\n    \r\n    if(boggle_board[row][col] === remaining.charAt(0))\r\n    { //we found the next spot!\r\n\r\n        global.paint_map[row][col] = true; \r\n\r\n        //try all of the other directions\r\n        let new_remaining = remaining.substring(1); //get remaining letters we need to find\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row-1, col, boggle_board) //square above\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row+1, col, boggle_board) //square below\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row, col-1, boggle_board) //square left\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row, col+1, boggle_board) //square right\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row-1, col-1, boggle_board) //upper left \r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row+1, col+1, boggle_board) //lower right\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row+1, col-1, boggle_board) //lower left\r\n\r\n        recursivelyFindAllWords(word,  new_remaining, row-1, col+1, boggle_board) //upper right\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nfunction checkInBounds(row, col)\r\n{\r\n\r\n    if(row < 0)\r\n    {\r\n        return false \r\n    }\r\n    else if(row >= global.board_size)\r\n    {\r\n        return false\r\n\r\n    } else if (col < 0)\r\n    {\r\n        return false\r\n\r\n    }\r\n    else if ( col >= global.board_size)\r\n    {\r\n        return false\r\n\r\n    }\r\n\r\n\r\n    return true\r\n}\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}